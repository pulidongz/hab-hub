{"ast":null,"code":"import _objectWithoutProperties from \"/home/pul/hab_ews/frontend/hab_ews/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _get from \"/home/pul/hab_ews/frontend/hab_ews/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _objectSpread from \"/home/pul/hab_ews/frontend/hab_ews/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _assertThisInitialized from \"/home/pul/hab_ews/frontend/hab_ews/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"/home/pul/hab_ews/frontend/hab_ews/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/pul/hab_ews/frontend/hab_ews/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/pul/hab_ews/frontend/hab_ews/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/pul/hab_ews/frontend/hab_ews/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/pul/hab_ews/frontend/hab_ews/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/home/pul/hab_ews/frontend/hab_ews/src/leaflet/src/LayersControl.js\";\nimport { Control } from 'leaflet';\nimport React, { cloneElement, Component, Children, Fragment } from 'react';\nimport { LeafletProvider, withLeaflet } from './context';\nimport MapControl from './MapControl';\n// Abtract class for layer container, extended by BaseLayer and Overlay\nexport var ControlledLayer =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(ControlledLayer, _Component);\n\n  function ControlledLayer() {\n    _classCallCheck(this, ControlledLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ControlledLayer).apply(this, arguments));\n  }\n\n  _createClass(ControlledLayer, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(_ref) {\n      var checked = _ref.checked;\n\n      if (this.props.leaflet.map == null) {\n        return;\n      } // Handle dynamically (un)checking the layer => adding/removing from the map\n\n\n      if (this.props.checked === true && (checked == null || checked === false)) {\n        this.props.leaflet.map.addLayer(this.layer);\n      } else if (checked === true && (this.props.checked == null || this.props.checked === false)) {\n        this.props.leaflet.map.removeLayer(this.layer);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.props.removeLayerControl(this.layer);\n    }\n  }, {\n    key: \"addLayer\",\n    value: function addLayer() {\n      throw new Error('Must be implemented in extending class');\n    }\n  }, {\n    key: \"removeLayer\",\n    value: function removeLayer(layer) {\n      this.props.removeLayer(layer);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return children ? React.createElement(LeafletProvider, {\n        value: this.contextValue,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 68\n        },\n        __self: this\n      }, children) : null;\n    }\n  }]);\n\n  return ControlledLayer;\n}(Component);\n\nvar BaseLayer =\n/*#__PURE__*/\nfunction (_ControlledLayer) {\n  _inherits(BaseLayer, _ControlledLayer);\n\n  function BaseLayer(props) {\n    var _this;\n\n    _classCallCheck(this, BaseLayer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseLayer).call(this, props));\n\n    _this.addLayer = function (layer) {\n      _this.layer = layer; // Keep layer reference to handle dynamic changes of props\n\n      var _this$props = _this.props,\n          addBaseLayer = _this$props.addBaseLayer,\n          checked = _this$props.checked,\n          name = _this$props.name;\n      addBaseLayer(layer, name, checked);\n    };\n\n    _this.contextValue = _objectSpread({}, props.leaflet, {\n      layerContainer: {\n        addLayer: _this.addLayer.bind(_assertThisInitialized(_this)),\n        removeLayer: _this.removeLayer.bind(_assertThisInitialized(_this))\n      }\n    });\n    return _this;\n  }\n\n  return BaseLayer;\n}(ControlledLayer);\n\nvar Overlay =\n/*#__PURE__*/\nfunction (_ControlledLayer2) {\n  _inherits(Overlay, _ControlledLayer2);\n\n  function Overlay(props) {\n    var _this2;\n\n    _classCallCheck(this, Overlay);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Overlay).call(this, props));\n\n    _this2.addLayer = function (layer) {\n      _this2.layer = layer; // Keep layer reference to handle dynamic changes of props\n\n      var _this2$props = _this2.props,\n          addOverlay = _this2$props.addOverlay,\n          checked = _this2$props.checked,\n          name = _this2$props.name;\n      addOverlay(layer, name, checked);\n    };\n\n    _this2.contextValue = _objectSpread({}, props.leaflet, {\n      layerContainer: {\n        addLayer: _this2.addLayer.bind(_assertThisInitialized(_this2)),\n        removeLayer: _this2.removeLayer.bind(_assertThisInitialized(_this2))\n      }\n    });\n    return _this2;\n  }\n\n  return Overlay;\n}(ControlledLayer);\n\nvar LayersControl =\n/*#__PURE__*/\nfunction (_MapControl) {\n  _inherits(LayersControl, _MapControl);\n\n  function LayersControl(props) {\n    var _this3;\n\n    _classCallCheck(this, LayersControl);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(LayersControl).call(this, props));\n    _this3.controlProps = {\n      addBaseLayer: _this3.addBaseLayer.bind(_assertThisInitialized(_this3)),\n      addOverlay: _this3.addOverlay.bind(_assertThisInitialized(_this3)),\n      leaflet: props.leaflet,\n      removeLayer: _this3.removeLayer.bind(_assertThisInitialized(_this3)),\n      removeLayerControl: _this3.removeLayerControl.bind(_assertThisInitialized(_this3))\n    };\n    return _this3;\n  }\n\n  _createClass(LayersControl, [{\n    key: \"createLeafletElement\",\n    value: function createLeafletElement(props) {\n      var _children = props.children,\n          options = _objectWithoutProperties(props, [\"children\"]);\n\n      return new Control.Layers(undefined, undefined, options);\n    }\n  }, {\n    key: \"updateLeafletElement\",\n    value: function updateLeafletElement(fromProps, toProps) {\n      _get(_getPrototypeOf(LayersControl.prototype), \"updateLeafletElement\", this).call(this, fromProps, toProps);\n\n      if (toProps.collapsed !== fromProps.collapsed) {\n        if (toProps.collapsed === true) {\n          this.leafletElement.collapse();\n        } else {\n          this.leafletElement.expand();\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this4 = this;\n\n      setTimeout(function () {\n        _get(_getPrototypeOf(LayersControl.prototype), \"componentWillUnmount\", _this4).call(_this4);\n      }, 0);\n    }\n  }, {\n    key: \"addBaseLayer\",\n    value: function addBaseLayer(layer, name) {\n      var checked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (checked && this.props.leaflet.map != null) {\n        this.props.leaflet.map.addLayer(layer);\n      }\n\n      this.leafletElement.addBaseLayer(layer, name);\n    }\n  }, {\n    key: \"addOverlay\",\n    value: function addOverlay(layer, name) {\n      var checked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (checked && this.props.leaflet.map != null) {\n        this.props.leaflet.map.addLayer(layer);\n      }\n\n      this.leafletElement.addOverlay(layer, name);\n    }\n  }, {\n    key: \"removeLayer\",\n    value: function removeLayer(layer) {\n      if (this.props.leaflet.map != null) {\n        this.props.leaflet.map.removeLayer(layer);\n      }\n    }\n  }, {\n    key: \"removeLayerControl\",\n    value: function removeLayerControl(layer) {\n      this.leafletElement.removeLayer(layer);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var children = Children.map(this.props.children, function (child) {\n        return child ? cloneElement(child, _this5.controlProps) : null;\n      });\n      return React.createElement(Fragment, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 189\n        },\n        __self: this\n      }, children);\n    }\n  }]);\n\n  return LayersControl;\n}(MapControl);\n\nvar LayersControlExport = withLeaflet(LayersControl);\nLayersControlExport.BaseLayer = BaseLayer;\nLayersControlExport.Overlay = Overlay;\nexport default LayersControlExport;","map":{"version":3,"sources":["/home/pul/hab_ews/frontend/hab_ews/src/leaflet/src/LayersControl.js"],"names":["Control","React","cloneElement","Component","Children","Fragment","LeafletProvider","withLeaflet","MapControl","ControlledLayer","checked","props","leaflet","map","addLayer","layer","removeLayer","removeLayerControl","Error","children","contextValue","BaseLayer","addBaseLayer","name","layerContainer","bind","Overlay","addOverlay","LayersControl","controlProps","_children","options","Layers","undefined","fromProps","toProps","collapsed","leafletElement","collapse","expand","setTimeout","child","LayersControlExport"],"mappings":"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","sourcesContent":["// @flow\n\nimport { Control, type Layer } from 'leaflet'\nimport React, {\n  cloneElement,\n  Component,\n  Children,\n  Fragment,\n  type ChildrenArray,\n  type Element,\n} from 'react'\n\nimport { LeafletProvider, withLeaflet } from './context'\nimport MapControl from './MapControl'\nimport type {\n  AddLayerHandler,\n  RemoveLayerHandler,\n  LeafletContext,\n  MapControlProps,\n} from './types'\n\ntype ControlledLayerProps = {\n  addBaseLayer: AddLayerHandler,\n  addOverlay: AddLayerHandler,\n  checked?: boolean,\n  children: Element<*>,\n  leaflet: LeafletContext,\n  name: string,\n  removeLayer: RemoveLayerHandler,\n  removeLayerControl: RemoveLayerHandler,\n}\n\n// Abtract class for layer container, extended by BaseLayer and Overlay\nexport class ControlledLayer extends Component<ControlledLayerProps> {\n  contextValue: LeafletContext\n  layer: ?Layer\n\n  componentDidUpdate({ checked }: ControlledLayerProps) {\n    if (this.props.leaflet.map == null) {\n      return\n    }\n    // Handle dynamically (un)checking the layer => adding/removing from the map\n    if (this.props.checked === true && (checked == null || checked === false)) {\n      this.props.leaflet.map.addLayer(this.layer)\n    } else if (\n      checked === true &&\n      (this.props.checked == null || this.props.checked === false)\n    ) {\n      this.props.leaflet.map.removeLayer(this.layer)\n    }\n  }\n\n  componentWillUnmount() {\n    this.props.removeLayerControl(this.layer)\n  }\n\n  addLayer() {\n    throw new Error('Must be implemented in extending class')\n  }\n\n  removeLayer(layer: Layer) {\n    this.props.removeLayer(layer)\n  }\n\n  render() {\n    const { children } = this.props\n    return children ? (\n      <LeafletProvider value={this.contextValue}>{children}</LeafletProvider>\n    ) : null\n  }\n}\n\nclass BaseLayer extends ControlledLayer {\n  constructor(props: ControlledLayerProps) {\n    super(props)\n    this.contextValue = {\n      ...props.leaflet,\n      layerContainer: {\n        addLayer: this.addLayer.bind(this),\n        removeLayer: this.removeLayer.bind(this),\n      },\n    }\n  }\n\n  addLayer = (layer: Layer) => {\n    this.layer = layer // Keep layer reference to handle dynamic changes of props\n    const { addBaseLayer, checked, name } = this.props\n    addBaseLayer(layer, name, checked)\n  }\n}\n\nclass Overlay extends ControlledLayer {\n  constructor(props: ControlledLayerProps) {\n    super(props)\n    this.contextValue = {\n      ...props.leaflet,\n      layerContainer: {\n        addLayer: this.addLayer.bind(this),\n        removeLayer: this.removeLayer.bind(this),\n      },\n    }\n  }\n\n  addLayer = (layer: Layer) => {\n    this.layer = layer // Keep layer reference to handle dynamic changes of props\n    const { addOverlay, checked, name } = this.props\n    addOverlay(layer, name, checked)\n  }\n}\n\ntype LeafletElement = Control.Layers\ntype LayersControlProps = {\n  children: ChildrenArray<*>,\n  collapsed?: boolean,\n} & MapControlProps\n\nclass LayersControl extends MapControl<LeafletElement, LayersControlProps> {\n  controlProps: {\n    addBaseLayer: AddLayerHandler,\n    addOverlay: AddLayerHandler,\n    removeLayer: RemoveLayerHandler,\n    removeLayerControl: RemoveLayerHandler,\n  }\n\n  constructor(props: LayersControlProps) {\n    super(props)\n    this.controlProps = {\n      addBaseLayer: this.addBaseLayer.bind(this),\n      addOverlay: this.addOverlay.bind(this),\n      leaflet: props.leaflet,\n      removeLayer: this.removeLayer.bind(this),\n      removeLayerControl: this.removeLayerControl.bind(this),\n    }\n  }\n\n  createLeafletElement(props: LayersControlProps): LeafletElement {\n    const { children: _children, ...options } = props\n    return new Control.Layers(undefined, undefined, options)\n  }\n\n  updateLeafletElement(\n    fromProps: LayersControlProps,\n    toProps: LayersControlProps,\n  ) {\n    super.updateLeafletElement(fromProps, toProps)\n    if (toProps.collapsed !== fromProps.collapsed) {\n      if (toProps.collapsed === true) {\n        this.leafletElement.collapse()\n      } else {\n        this.leafletElement.expand()\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    setTimeout(() => {\n      super.componentWillUnmount()\n    }, 0)\n  }\n\n  addBaseLayer(layer: Layer, name: string, checked: boolean = false) {\n    if (checked && this.props.leaflet.map != null) {\n      this.props.leaflet.map.addLayer(layer)\n    }\n    this.leafletElement.addBaseLayer(layer, name)\n  }\n\n  addOverlay(layer: Layer, name: string, checked: boolean = false) {\n    if (checked && this.props.leaflet.map != null) {\n      this.props.leaflet.map.addLayer(layer)\n    }\n    this.leafletElement.addOverlay(layer, name)\n  }\n\n  removeLayer(layer: Layer) {\n    if (this.props.leaflet.map != null) {\n      this.props.leaflet.map.removeLayer(layer)\n    }\n  }\n\n  removeLayerControl(layer: Layer) {\n    this.leafletElement.removeLayer(layer)\n  }\n\n  render() {\n    const children = Children.map(this.props.children, child => {\n      return child ? cloneElement(child, this.controlProps) : null\n    })\n    return <Fragment>{children}</Fragment>\n  }\n}\n\nconst LayersControlExport: Object = withLeaflet(LayersControl)\n\nLayersControlExport.BaseLayer = BaseLayer\nLayersControlExport.Overlay = Overlay\n\nexport default LayersControlExport\n"]},"metadata":{},"sourceType":"module"}